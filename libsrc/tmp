
/*  For multiplying point-wise
 *  No assumption that interpolation is not needed.
 *  vec3 add is in fractional coordinates and describes where the centre
 *  of the fftAtom should be in relation to Crystal.
 */
double VagFFT::operation(VagFFTPtr fftCrystal, VagFFTPtr fftAtom, vec3 add,
                      MapScoreType mapScoreType, std::vector<CoordVal> *vals,
                      bool sameScale)
{
	/* I rarely comment something so heavily but I will get confused if
	 * I don't, this time, as I can't soak the protocol into the variable
	 * names. Bear in mind the three coordinate systems:
	 * (a) Angstroms
	 * (b) Crystal voxels
	 * (c) Atom voxels */

	double volume = 1;

	/* Bring the fractional coordinate of the atom into range 0 < frac <= 1 */
	if (mapScoreType != MapScoreAddNoWrap)
	{
		FFT::collapseFrac(&add.x, &add.y, &add.z);
	}

	/* Multiply by the relative dimensions of the crystal */
	double multX = add.x * fftCrystal->nx;
	double multY = add.y * fftCrystal->ny;
	double multZ = add.z * fftCrystal->nz;

	/* Get the remainder after subtracting a number of whole voxels */
	vec3 atomOffset; // in crystal coordinates actually, converted later.
	atomOffset.x = fmod(multX, 1.);
	atomOffset.y = fmod(multY, 1.);
	atomOffset.z = fmod(multZ, 1.);

	/* Store the non-remainder whole voxel values for way later. */
	vec3 atomWholeCoords = make_vec3((int)multX, (int)multY, (int)multZ);

	/* Prepare a matrix to convert crystal voxels into atomic voxels */
	mat3x3 crystal2AtomVox = mat3x3_mult_mat3x3(fftAtom->getBasisInverse(),
	                                            fftCrystal->getBasis());

	/* Prepare a matrix to convert atomic voxels into crystal voxels */
	mat3x3 atomVox2Crystal = mat3x3_mult_mat3x3(fftCrystal->getBasisInverse(),
	                                            fftAtom->getBasis());

	/* Apply this offset and reverse it. This small offset must be added
	 * to all future atomic coordinates prior to interpolation. This
	 * is therefore now in atom voxels.*/
	mat3x3_mult_vec(crystal2AtomVox, &atomOffset);
	vec3_mult(&atomOffset, -1);

	mat3x3 crystBasis = fftCrystal->getBasis();
	mat3x3 atomBasis = fftAtom->getBasis();
	double vol_corr = mat3x3_volume(crystBasis) / mat3x3_volume(atomBasis);

	/* There will be an additional shift having moved the atom by
	 * half the dimension length which needs to be taken into account, 
	 * unfortunately. */
	vec3 atomShift = make_vec3((double)(-fftAtom->nx) * 0.5,
	                           (double)(-fftAtom->ny) * 0.5,
	                           (double)(-fftAtom->nz) * 0.5);
	vec3 shift = mat3x3_mult_vec(atomVox2Crystal, atomShift);

	/* In crystal voxels at the moment - don't worry about fractional
	 * shifts. */
	vec3 shiftRemainder = make_vec3(fmod(shift.x, 1),
	                                fmod(shift.y, 1),
	                                fmod(shift.z, 1));

	vec3 wholeShiftOnly = make_vec3(shift.x - shiftRemainder.x - 1,
	                                shift.y - shiftRemainder.y - 1,
	                                shift.z - shiftRemainder.z - 1);

	shiftRemainder.x = 1 + shiftRemainder.x;
	shiftRemainder.y = 1 + shiftRemainder.y;
	shiftRemainder.z = 1 + shiftRemainder.z;

	/* The crystal voxels must be converted to atomic voxels to determine
	 * final offset for atom sampling. */
	mat3x3_mult_vec(crystal2AtomVox, &shiftRemainder);
	vec3_mult(&shiftRemainder, -1);

	/* Corner of atom as whole value offset in the crystal coordinates. */
	vec3 cornerCrystal = vec3_add_vec3(wholeShiftOnly, atomWholeCoords);

	/* Fractional offset in atomic coordinates, for each atom as a
	 * 	fraction of the crystal voxel. */
	atomOffset = vec3_add_vec3(atomOffset, shiftRemainder);
	vec3 crystOffset = mat3x3_mult_vec(atomVox2Crystal, atomOffset);
	
	/* We loop around these crystal voxel limits now (ss -> ms -> fs).
	 * We also break the loop if it exceeds the limits of our atom voxels
	 * during the loop itself. */

	int count = 0;

	/* Determine bounding box - 9th Dec 2017 */
	vec3 minAtom = make_vec3(0, 0, 0);
	vec3 maxAtom = make_vec3(0, 0, 0);

	for (int k = 0; k <= fftAtom->nz; k += fftAtom->nz)
	{
		for (int j = 0; j <= fftAtom->ny; j += fftAtom->ny)
		{
			for (int i = 0; i <= fftAtom->nx; i += fftAtom->nx)
			{
				vec3 atomCorner = make_vec3(i, j, k);
				vec3 toCrystal = mat3x3_mult_vec(atomVox2Crystal, atomCorner);
				toCrystal.x = (int)toCrystal.x;
				toCrystal.y = (int)toCrystal.y;
				toCrystal.z = (int)toCrystal.z;

				vec3_min_each(&minAtom, toCrystal);
				vec3_max_each(&maxAtom, toCrystal);
			}
		}
	}

	/* Set all the voxels to zero if we are going to copy across info.
	 * We do not want any contamination with original Fc. */
	if (mapScoreType == MapScoreTypeCopyToSmaller)
	{
		fftAtom->wipe();
	}
	
	double step = 1;

	/* min/maxAtoms are in crystal coordinates.*/
	for (double k = minAtom.z; k < maxAtom.z; k += step)
	{
		for (double j = minAtom.y; j < maxAtom.y; j += step)
		{
			for (double i = minAtom.x; i < maxAtom.x; i += step)
			{
				/* Position currently in crystal coords - change to atom. */
				vec3 crystalPos = make_vec3(i, j, k);
				vec3 atomPos = crystalPos;

				if (!sameScale)
				{
					mat3x3_mult_vec(crystal2AtomVox, &atomPos);

					if (atomPos.x < 0 || atomPos.y < 0 || atomPos.z < 0)
					{
						continue;
					}

					if (atomPos.x > fftAtom->nx || atomPos.y > fftAtom->ny
					    || atomPos.z > fftAtom->nz)
					{
						continue;
					}
				}

				/* Now we must find the relative crystal voxel to write this
				 * density value to, given that the atom was wrapped around
				 * the origin (center). This should work regardless of odd/
				 * even dimension lengths. */

				/* We add the tiny offset which resulted from the atom
				 * falling between two voxels, in atomic voxels */
				vec3_add_to_vec3(&atomPos, atomOffset);
				
				/* Find the interpolated value which atomPos falls on */
				double atomReal = 0; double atomImag = 0;

				while (atomPos.x < 0) atomPos.x += fftAtom->nx;
				while (atomPos.y < 0) atomPos.y += fftAtom->ny;
				while (atomPos.z < 0) atomPos.z += fftAtom->nz;

				while (atomPos.x >= fftAtom->nx) atomPos.x -= fftAtom->nx;
				while (atomPos.y >= fftAtom->ny) atomPos.y -= fftAtom->ny;
				while (atomPos.z >= fftAtom->nz) atomPos.z -= fftAtom->nz;

				atomReal = fftAtom->cubic_interpolate(atomPos, 0);

				if (vals != NULL)
				{
					atomImag = fftAtom->cubic_interpolate(atomPos, 1);
				}

				if (atomReal < 1e-6 && mapScoreType == MapScoreTypeCorrel)
				{
					continue;
				}

				/* We add the crystal offset so we don't end up with thousands
				 * of atoms at the very centre of our map */
				vec3 cVox = vec3_add_vec3(crystalPos, cornerCrystal);

				if (mapScoreType == MapScoreAddNoWrap)
				{
					if (cVox.x < -fftCrystal->nx / 2 || 
					    cVox.y < -fftCrystal->ny / 2 ||
					    cVox.z < -fftCrystal->nz / 2)
					{
						continue;
					}					

					if (cVox.x > fftCrystal->nx / 2 ||
					    cVox.y > fftCrystal->ny / 2 ||
					    cVox.z > fftCrystal->nz / 2)
					{
						continue;
					}
				}

				while (cVox.x < 0) cVox.x += fftCrystal->nx;
				while (cVox.y < 0) cVox.y += fftCrystal->ny;
				while (cVox.z < 0) cVox.z += fftCrystal->nz;

				while (cVox.x >= fftCrystal->nx) cVox.x -= fftCrystal->nx;
				while (cVox.y >= fftCrystal->ny) cVox.y -= fftCrystal->ny;
				while (cVox.z >= fftCrystal->nz) cVox.z -= fftCrystal->nz;

				/* Get the index of this final crystal voxel. */
				long cIndex = fftCrystal->element(cVox.x + 0.5,
				                                  cVox.y + 0.5,
				                                  cVox.z + 0.5);

				count++;

				if (mapScoreType == MapScoreTypeCorrel)
				{
					// We do NOT need to interpolate //
					double realCryst = fftCrystal->getReal(cIndex);

					if (vals)
					{
						CoordVal val;
						val.fo = realCryst;
						val.fc = atomReal;
						val.weight = atomImag;
						#ifdef COORDVAL_FULL
						vec3 frac = fftCrystal->fracFromElement(cIndex);
						val.pos = frac;
						#endif

						vals->push_back(val);
					}
				}
				else if (mapScoreType == MapScoreTypeCopyToSmaller)
				{
					double realCryst = fftCrystal->getReal(cIndex);
					int ele = fftAtom->element(atomPos);

					fftAtom->setElement(ele, realCryst, 0);
				}
				else if (mapScoreType == MapScoreTypeNone ||
				         mapScoreType == MapScoreAddNoWrap)
				{
					/* Add the density to the real value of the crystal
					 * voxel. */

					fftCrystal->data[cIndex][0] += atomReal * vol_corr;
				}
			}
		}
	}

	return 0;
}
